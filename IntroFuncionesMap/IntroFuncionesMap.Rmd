---
title: "Funciones Map"
output: 
  learnr::tutorial:
    progressive: true
    allow_skip: false
runtime: shiny_prerendered
tutorial:
  version: 1.0
---

```{r setup, include=FALSE, message = FALSE, warning=FALSE}
library(learnr)
library(tidyverse)
library(stringr)

ldeaths <- list(`1974` = c(Jan = 3035, Feb = 2552, Mar = 2704, Apr = 2554, May = 2014, Jun = 1655, Jul = 1721, Aug = 1524, Sep = 1596, Oct = 2074, Nov = 2199, Dec =  2512),
                `1975` = c(Jan = 2933, Feb = 2889, Mar = 2938, Apr = 2497, May = 1870, Jun = 1726, Jul = 1607, Aug = 1545, Sep = 1396, Oct = 1787, Nov = 2076, Dec =  2837),
                `1976` = c(Jan = 2787, Feb = 3891, Mar = 3179, Apr = 2011, May = 1636, Jun = 1580, Jul = 1489, Aug = 1300, Sep = 1356, Oct = 1653, Nov = 2013, Dec =  2823),
                `1977` = c(Jan = 3102, Feb = 2294, Mar = 2385, Apr = 2444, May = 1748, Jun = 1554, Jul = 1498, Aug = 1361, Sep = 1346, Oct = 1564, Nov = 1640, Dec =  2293),
                `1978` = c(Jan = 2815, Feb = 3137, Mar = 2679, Apr = 1969, May = 1870, Jun = 1633, Jul = 1529, Aug = 1366, Sep = 1357, Oct = 1570, Nov = 1535, Dec =  2491),
                `1979` = c(Jan = 3084, Feb = 2605, Mar = 2573, Apr = 2143, May = 1693, Jun = 1504, Jul = 1461, Aug = 1354, Sep = 1333, Oct = 1492, Nov = 1781, Dec =  1915))
                

checker <- function(label, user_code, check_code, envir_result, evaluate_result, ...) {
  list(message = check_code, correct = TRUE, location = "append")
}
tutorial_options(exercise.timelimit = 60, exercise.checker = checker)
knitr::opts_chunk$set(error = TRUE, out.width = "100%")
```

## Map

###  

Las funciones `map()` están en el paquete `purrr`. `purrr` es un paquete con herramientas que pueden ayudarte a aplicar funciones en una forma iterativa. 

`purrr` se instala cuando ejecutas run `install.packages("tidyverse")`.  

`purrr` se carga cuando ejecutas `library(tidyverse)`

* Escribe el código para cargar `purrr` (ya está instalado) y luego haz click en _Submit Answer_.

```{r purrr, exercise = TRUE}

```

```{r purrr-check}
'Purrr-fecto. Ahora puedes usar las funciones purrr. También puedes instalar y cargar el paquete purrr sólo, sin los otros paquetes tidyverse. Para hacerlo, usa install.packages("purrr") y library(purrr).'
```

```{r purrr-solution}
library(tidyverse)
```


### map()

El trabajo de la función `map()` de `purrr` es aplicar una función R a cada elemento de un vector R. `map()` requiere dos argumentos, en este orden:

1. Un vector sobre el que iterar. `map()` funciona tanto con vectores simples como con listas.
2. Una función para aplicar a cada elemento del vector. La función `map()` espera el nombre de la función sin las comillas alrededor y sin paréntesis detrás.

En este ejemplo, `map()` aplica la función de valor absoluto a cada elemento de números `negativos`.

```{r echo = TRUE}
negativos <- list(-25, -31, -111)
map(negativos, abs)
```

###  

Piensa en `map()` de esta manera: cada recuadro de cuadraditos representa un vector y cada cuadradito representa un elemento del vector:

```{r echo=FALSE, out.width = "70%"}
knitr::include_graphics("images/map.png")
```

###  

```{r echo = TRUE}
list1 <- list(1, 2, 3, 4, 5)
```

* Utiliza el fragmento de código a continuación para _mapear_ `log()` sobre los elementos de `list1`. Luego hacé clic en _Submit Answer_.

```{r map1, exercise = TRUE, exercise.eval = TRUE}

```

```{r map1-setup}
list1 <- list(1, 2, 3, 4, 5)
```

```{r map1-solution}
map(list1, log)
```

```{r map1-hint-1}
"Empieza con map()."
```

```{r map1-hint-2}
"Poné a list1 como el primer argumento de map()."
```

```{r map1-hint-3}
"Poné log como el segundo argumento de map()."
```

```{r map1-hint-4}
"No ponga paréntesis detrás de log. log devuelve el código almacenado en la función de logaritmo. log() ejecuta el código y devuelve los resultados, que luego se pasarían a map() (en caso que log() no arrojó un error, es decir, en el caso que log() necesita un argumento para ejecutar el código correctamente)."
```

```{r map1-check}
"Excelente. Puedes usar map() con cualquier función para iterar sobre los elementos de un vector. map() devolverá los resultados en una lista, lo que significa que map() puede manejar cualquier salida que cree su función. ¿Por qué? Porque puedes poner cualquier cosa en una lista."
```

### Programación funcional

Puede parecerte extraño que `map()` tome una función como argumento, pero no es extraño en absoluto. En R, las funciones son objetos que se pueden pasar como todos los demás.

Estas preguntas te ayudarán a familiarizarte con esta idea.

* Usa este bloque de código como un bloc de notas para ayudarte a responder las preguntas que aparecen a continuación.

```{r map3, exercise = TRUE}

```

```{r q1, echo=FALSE}
quiz(caption = "",
     question("qué devuelve `log`?",
              answer("0"),
              answer("Un error"),
              answer("La función guardada en el objeto llamado `log`", correct = TRUE, message = "log es solo un objeto que contiene una función. Esto es cierto para los nombres de todas las funciones R. Puedes devolver la función sin ejecutarla llamando al nombre de la función sin paréntesis detrás."),
              allow_retry = TRUE
     ),
     question("Qué retorna `log()`?",
              answer("0"),
              answer("Un error", correct = TRUE, message = 'Los paréntesis son el "botón play" para las funciones R. Cuando colocas los paréntesis detrás del nombre de un objeto que contiene una función, R ejecuta la función. Desafortunadamente, la función log requiere un argumento para hacer su trabajo. No proporcionamos uno aquí, por lo que obtenemos un error. Para ver el efecto de los paréntesis con mayor claridad, compare Sys.Date() con Sys.Date. La función Sys.Date no requiere un argumento.'),
              answer("La función guardada en el objeto llamado `log`"),
              allow_retry = TRUE
     ),
     question("qué devuelve `log(1)`?",
              answer("0", correct = TRUE, message = "Este es el resultado de ejecutar log en 1. Los paréntesis ejecutan la función guardada en log y pasan a la función el argumento 1, que proporcionamos entre paréntesis."),
              answer("Un error"),
              answer("La función guardada en el objeto llamado `log`"),
              allow_retry = TRUE
     )
)
```

Por cierto, deberás hacer clic en _Run Code_ arriba al menos una vez antes de poder continuar.

### ¿Qué pasa con la salida?

Le das a `map()` un vector y una función. `map()` siempre te retorna una lista. El elemento _enécimo_ de la lista será el resultado de aplicar su función al elemento _enécimo_ de su vector.

Esto es conveniente por dos razones:

1. `map()` puede manejar cualquier cosa que salga de tu función, incluso un dataframe. ¿Por qué? Porque puedes poner cualquier cosa en una lista.
2. `map()` es fácil de usar con _pipes_ porque toma un vector como primer argumento y devuelve un vector (una lista es un tipo de vector). Veamos un ejemplo.

* Predice lo que devolverá este código y luego hacé clic en _Submit Answer_.

```{r map2, exercise = TRUE}
list1 %>% 
  map(log) %>% 
  map(round)
```

```{r map2-setup}
list1 <- list(1, 2, 3, 4, 5)
```

```{r map2-hint}
"Hacé clic en Submit Answer para ver si tu predicción es correcta."
```

```{r map2-check}
"El código primero tomó el registro de cada elemento con log(). Luego redondeó cada respuesta al número entero más cercano con round()."
```

## Entradas y Salidas

### Argumentos

¿Qué pasa si desea pasar `map()` una función que usa argumentos adicionales?

Por ejemplo, le darías a `round()` un argumento adicional llamado `digits` si quisieras redondear a un cierto número de dígitos después del lugar decimal, p. ej.

```{r}
round(3.141593, digits = 2)
```

###  

Puedes pasar argumentos adicionales para tu función _a_ `map()` como si fueran argumentos _de_ `map()`. `map()` enviará los argumentos a su función cuando llame a la función. Casi siempre querrá nombrar estos argumentos, p. Ej.

```{r map-args}
list1 %>% 
  map(log) %>% 
  map(round, digits = 2)
```

###  

¿Puedes hacerlo?

* Utiliza el poco conocido argumento `base` de `log()` para calcular el logaritmo base 2 de cada elemento en `list1`. Luego hacé clic en _Submit Answer_.

```{r map4, exercise = TRUE}

```

```{r map4-setup}
list1 <- list(1, 2, 3, 4, 5)
```

```{r map4-solution}
map(list1, log, base = 2)
```

```{r map4-hint}
"Empieza con map(list1, log)."
```

```{r map4-check}
"Buen trabajo. Puede pasar tantos argumentos como desee a través de map(), asegúrese de separar cada uno con una coma, ej. map(list1, rnorm, media = 1, sd = 2)."
```

### Formatos de salida

Hasta ahora, todas nuestras funciones han devuelto una lista de números. Esto es no resulta muy útil, porque (como has visto) puede ser difícil trabajar con listas.

¿Qué sucede si deseas devolver los resultados como un vector simple (es decir, no como una lista)?

### map_dbl()

Puedes hacer eso con `map_dbl()`. 

`map_dbl()` trabaja igual que `map()`, excepto que devuelve sus resultados en un vector numérico. (dbl es la abreviatura de "double", el nombre que se le da en computación a un número que puede contener un decimal).

* Cambia el siguiente código para que use `map_dbl()` luego hacé click en _Submit Answer_.

```{r map_dbl, exercise = TRUE}
map(list1, log)
```

```{r map_dbl-setup}
list1 <- list(1, 2, 3, 4, 5)
```

```{r map_dbl-solution}
map_dbl(list1, log)
```

```{r map_dbl-check}
"Buen trabajo. Ahora sus resultados regresan como un vector numérico. Esto es útil. Por ejemplo, puede pasar los resultados directamente a round() sin usar otra llamada a map(): list1 %>% map_dbl(log) %>% round()."
```

### Otro tipo de salidas

Pero supongamos que nuestra función no devuelve dobles. Por ejemplo, `str_sub()` del paquete `stringr` devuelve caracteres. Aquí, devolverá el primer carácter de cada cadena.

* ¿Funcionará el siguiente código? Hacé clic en _Run code_ para averiguarlo.

```{r map_dbl2, exercise = TRUE}
library(stringr)
strings <- list("Mary", "John", "Jill")
map_dbl(strings, str_sub, start = 1, end = 1)
```

###  

El código no funcionó porque `str_sub()` devuelve un conjunto de caracteres, pero `map_dbl()` construye un vector doble (numérico).

En R, cada vector que no es una lista tiene un _tipo_. Solo puedes guardar _dobles_ en un vector doble. Deberías guardar los caracteres en un _vector de caracteres_. ¿Nos quedamos sin suerte?

###  

No! `purrr` tiene ocho versiones de `map()`. Cada una retorna su resultado en diferente formato. 

Función      | Salida
------------ | -------------
`map()`      |  lista
`map_chr()`  |  vector de characteres (character)
`map_dbl()`  |  vector de dobles (double (numeric))
`map_dfc()`  |  data frame (salida enlazada por columnas)
`map_dfr()`  |  data frame (salida enlazada por filas)
`map_int()`  |  vector de enteros (integer)
`map_lgl()`  |  vector de valores lógicos (logical)
`walk()`     |  devuelve la entrada de forma invisible (se utiliza para desencadenar otras tareas)

La última función, `walk()`, se usa para funciones que no devuelven una salida a la línea de comando, como funciones que trazan gráficos o guardan archivos.
###  

La idea detrás de `purrr` es que puedes elegir la función de `map` que devuelve el tipo de salida que necesitas.

* Reemplaza `map_dbl()` en el código siguiente con la función que permitirá que el código funcione. Luego hacé clic en _Submit Answer_.

```{r map_chr, exercise = TRUE}
strings <- list("María", "Juan", "René")

map_dbl(strings, str_sub, start = 1, end = 1)
```

```{r map_chr-hint}
"str_sub() retorna caracteres."
```

```{r map_chr-solution}
strings <- list("María", "Juan", "René")

map_chr(strings, str_sub, start = 1, end = 1)
```

```{r map_chr-check}
"Gran trabajo. Ahora reforcemos nuestro conocimiento de `map()` usándolo para resolver un desafío de datos."
```

## Caso de Estudio

###  

`ldeaths` es una lista que registra las muertes mensuales en el Reino Unido por enfermedades pulmonares. Los datos abarcan los años 1974 a 1979 y están divididos por año.

* Echale un vistazo. Hacé clic en _Submit Answer_ para ver el contenido de `ldeaths`.

```{r ldeaths-1, exercise = TRUE}
ldeaths
```

```{r ldeaths-1-check}
"Estos son los datos que explorarás. ldeaths es una versión reformateada de la serie temporal de ldeaths que viene en R base."
```

### Muertes por año

Sería útil saber cuántas personas mueren cada año por enfermedades pulmonares. Entonces podrías ver si las muertes disminuyeron con el tiempo. ¿Puedes hacerlo?

* Utiliza una función de map para calcular la suma de cada vector en "ldeaths". Luego hacé clic en _Submit Answer_.

```{r ldeaths-sum, exercise = TRUE}

```

```{r ldeaths-sum-hint}
"Los resultados de la suma debe ser un número (doubles)."
```

```{r ldeaths-sum-solution}
map_dbl(ldeaths, sum)
```

```{r ldeaths-sum-check}
"Buen trabajo. Parece que las muertes disminuyeron con el tiempo (levemente). ¿Usaste map() o map_dbl()? Ambos funcionarán, pero map_dbl() devolverá sus resultados en un formato que es más fácil de inspeccionar y usar."
```

### Muertes totales

Da un paso más.

* Calcula el número _total_ de muertes en el conjunto de datos. Esta será la suma de su último resultado. Luego haga clic en _Submit Answer_.

```{r ldeaths-total, exercise = TRUE}

```

```{r ldeaths-total-hint-1}
"Esto va a tomar dos pasos."
```

```{r ldeaths-total-hint-2}
"El segundo paso será más fácil si usa map_dbl() en su primer paso."
```

```{r ldeaths-total-solution}
sum(map_dbl(ldeaths, sum))
```

```{r ldeaths-total-check}
"Buen trabajo. Primero, sumaste cada vector. Luego, sumaste los resultados. Es más fácil sumar los resultados si usa map_dbl() para sumar los vectores."
```

### Pipes

Ahora que estás realizando operaciones de varios pasos, debes comenzar a usar el operador _pipe_ si aún no lo has hecho. El operador _pipe_ (`%>%`) también es ideal para operaciones de un solo paso.

* Tómate un momento para convertir este código usando el operador _pipe_. Luego hacé clic en _Submit Answer_.

    Nota: Recuerda que el pipe toma la salida de lo que esté en el lado izquierdo y lo pasa al primer argumento de la función que está en el lado derecho. Entonces, `x %>% f()` es lo mismo que `f(x)` y `x %>% f()%>% g()` es lo mismo que `g(f(x))`.

```{r ldeaths-pipe, exercise = TRUE}
sum(map_dbl(ldeaths, sum))
```

```{r ldeaths-pipe-hint}
"Deberás utilizar dos pipes para convertir esta expresión."
```

```{r ldeaths-pipe-solution}
ldeaths %>% 
  map_dbl(sum) %>%
  sum()
```

```{r ldeaths-pipe-check}
"Utiliza pipes para el resto de este caso de estudio. con los pipes es más fácil construir sobre códigos anteriores y en la transformación de tus datos un paso a la vez. No puedo recomendar los pipes lo suficiente."
```

### Suma por mes

Vamos a sumar entre los meses para ver si hay un efecto estacional.

Matemáticamente, esto es tan simple como tus cálculos anteriores. Desde el punto de vista programático, es un desafío: tus datos no están configurados de una manera que facilite la suma de los meses. Necesitarás una estrategia.

###  

Una estrategia puede ser:

1. Hacer que sus datos se vean así:

```{r echo = FALSE}
ldeaths %>% 
  map(t) %>% 
  map_dfr(as_tibble)
```

2. Entonces puede usar la función `summary()` de _dplyr_ para sumar las columnas.

Hacé eso, pero te adverierto: te encontrarás con un par de sorpresas, como cuando trabajas con datos en la vida real.

### Paso 1 - Un data frame

Para el Paso 1, puedes usar una función de map para combinar tus vectores en un data frame. ¿Recuerdas qué funciones de map devuelven un sólo data frame? Había dos funciones.

###  

1. `map_dfr()` agrega cada elemento al primero como _filas_ (exactamente lo que queremos hacer)
2. `map_dfc()` agrega cada elemento al primero como _columnas_

But each function expects to iterate over a set of _data frames_ and `ldeaths` contains a set of vectors. To make `map_dfr()` work, you will need to pass it a function that turns the vectors in `ldeaths` into data frames for `map_dfr()` to combine.

### as_tibble()

R has many functions that can turn a vector into a data frame: `data.frame()`, `as.data.frame()`, `data_frame()`, `as_data_frame()`, are some of them. 

I prefer to use `as_tibble()`. `as_tibble()` converts the vector to a data frame _and_ adds the helpful tibble class to the data frame. As a result, the data frame prints nicely at the command line. 

* Try it out. Use `as_tibble()` to convert the vector below into a data frame.

```{r as_tibble, exercise = TRUE}
named_vec <- c(uno = 1, dos = 2, tres = 3)
named_vec
```

```{r as_tibble-solution}
named_vec <- c(uno = 1, dos = 2, tres = 3)
as_tibble(named_vec)
```

```{r as_tibble-check}
"Good job. as_tibble() comes in the tibble package, as do as_data_frame() and data_frame(). Like purrr, the tibble package is a member of the tidyverse."
```

###  

Now that you know how `as_tibble()` works,

* Use `map()` to map `as_tibble()` over the vectors in `ldeaths`. Then click Submit Answer. (For now, use `map()` instead of `map_dfr()`, this will help you see what happens step-by-step as you wrangle the data.)
* Inspect the results closely. What happens?

```{r as_tibble-2, exercise = TRUE}

```

```{r as_tibble-2-solution}
ldeaths %>% 
  map(as_tibble)
```

```{r as_tibble-2-check}
"Good job, you made each vector a tibble (i.e. a data frame)! But there is something funny happening here. Let's investigate."
```

### Row or column?

`as_tibble()` turned each vector into a data frame with one _column_. If you want the data frame below, you'll need to turn each vector into a data frame with one _row_ (that way `map_dfr()` can stack the rows on top of one another).

```{r echo = FALSE}
ldeaths %>% 
  map(t) %>% 
  map_dfr(as_tibble)
```

If you try running `map_dfr()` on our current output, it will stack your columns on top of one another to make a data frame with one long column. Go ahead, try it.

* Click Submit Answer. 

```{r fail, exercise = TRUE}
ldeaths %>% 
  map_dfr(as_tibble)
```

```{r fail-solution}
ldeaths %>% 
  map_dfr(as_tibble)
```

```{r fail-check}
"That's not what you want."
```

### How can you fix this?

Even though R displays simple vectors as if they were _row vectors_, R thinks of every vector as a _column vector_, even if that vector has names. So why display the vector as a row vector? To save screen space.

```{r}
ldeaths[[1]]
```

You can get the data frames you want if you first transpose the column vectors in `ldeaths` to row vectors. 

### t()

R's `t()` function does just that. 

```{r}
ldeaths[[1]]

t(ldeaths[[1]])
```

Don't be fooled by the way R displays the vectors. R only thinks of the second vector as a row vector. You can tell by the bracket notation in front of the vector. It indicates that this is the first _row_ of the result (but you can ignore the notation if it doesn't interest you).

### A data set

Now you can finish Step 1.

1. Use `map()` to apply `t()` to each vector in `ldeaths`.
2. Use `map_dfr()` to map `as_tibble()` over the transposed results. `map_dfr()` will combine the output into a single data frame. 
3. Click Submit Answer

```{r t, exercise = TRUE}

```

```{r t-solution}
ldeaths %>% 
  map(t) %>% 
  map_dfr(as_tibble)
```

```{r t-check}
"Excellent. Now you can finish."
```

### Step 2 - summarise()

How would you extend this code with `summarise()` from the dplyr package to compute the monthly totals?

_(You may need to take the Work with Data Primer to understand these final three sections.)_

```{r}
ldeaths %>% 
  map(t) %>% 
  map_dfr(as_tibble)
```

###  

Here's a surefire way to do it, but it requires a lot of typing; I'm summarising every column in the data frame. Let's use a shortcut instead.

```{r eval = FALSE}
ldeaths %>% 
  map(t) %>% 
  map_dfr(as_tibble) %>% 
  summarise(Jan = sum(Jan), 
            Feb = sum(Feb),
            Mar = sum(Mar),
            Apr = sum(Apr),
            May = sum(May),
            Jun = sum(Jun), 
            Jul = sum(Jul),
            Aug = sum(Aug),
            Sep = sum(Sep),
            Oct = sum(Oct),
            Nov = sum(Nov),
            Dec = sum(Dec))
```

### summarise_all()

dplyr contains a variant of `summarise()` named `summarise_all()`. To use `summarise_all()` give it a data frame and then one or more functions to apply to each column in the data frame. `summarise_all()` will apply each function to every column and return the results as a summary table.

* Use `summarise_all()` and the code below to sum across months. Look at the hints if you get stuck. Then click Submit Answer.

```{r all, exercise = TRUE}
ldeaths %>% 
  map(t) %>% 
  map_dfr(as_tibble)
```

```{r all-hint}
"You do not need to pass summarise_all() a data frame; it will inherit one from the pipe."
```

```{r all-solution}
ldeaths %>% 
  map(t) %>% 
  map_dfr(as_tibble) %>% 
  summarise_all(sum)
```

```{r all-check}
"Great Job! You can see a strong seasonal effect in the data: more lung related deaths happen in winter. You were able to do this because of the work you put into wrangling the data with purrr. Give yourself a pat on the back!"
```

### The End

Congratulations on making it to the end. You've learned the ins and outs of iterating with `map()`, but there is more to know.

When you are ready, the next tutorial will show you how to save a lot of time with `map()`'s syntax shortcuts. It will also show you what to do when you cannot find a function to map that does what you want.
