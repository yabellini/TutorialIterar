---
title: "Funciones Map"
output: 
  learnr::tutorial:
    progressive: true
    allow_skip: false
runtime: shiny_prerendered
tutorial:
  version: 1.0
---

```{r setup, include=FALSE, message = FALSE, warning=FALSE}
library(learnr)
library(tidyverse)
library(stringr)

ldeaths <- list(`1974` = c(Jan = 3035, Feb = 2552, Mar = 2704, Apr = 2554, May = 2014, Jun = 1655, Jul = 1721, Aug = 1524, Sep = 1596, Oct = 2074, Nov = 2199, Dec =  2512),
                `1975` = c(Jan = 2933, Feb = 2889, Mar = 2938, Apr = 2497, May = 1870, Jun = 1726, Jul = 1607, Aug = 1545, Sep = 1396, Oct = 1787, Nov = 2076, Dec =  2837),
                `1976` = c(Jan = 2787, Feb = 3891, Mar = 3179, Apr = 2011, May = 1636, Jun = 1580, Jul = 1489, Aug = 1300, Sep = 1356, Oct = 1653, Nov = 2013, Dec =  2823),
                `1977` = c(Jan = 3102, Feb = 2294, Mar = 2385, Apr = 2444, May = 1748, Jun = 1554, Jul = 1498, Aug = 1361, Sep = 1346, Oct = 1564, Nov = 1640, Dec =  2293),
                `1978` = c(Jan = 2815, Feb = 3137, Mar = 2679, Apr = 1969, May = 1870, Jun = 1633, Jul = 1529, Aug = 1366, Sep = 1357, Oct = 1570, Nov = 1535, Dec =  2491),
                `1979` = c(Jan = 3084, Feb = 2605, Mar = 2573, Apr = 2143, May = 1693, Jun = 1504, Jul = 1461, Aug = 1354, Sep = 1333, Oct = 1492, Nov = 1781, Dec =  1915))
                

checker <- function(label, user_code, check_code, envir_result, evaluate_result, ...) {
  list(message = check_code, correct = TRUE, location = "append")
}
tutorial_options(exercise.timelimit = 60, exercise.checker = checker)
knitr::opts_chunk$set(error = TRUE, out.width = "100%")
```

## Map

###  

Las funciones `map()` están en el paquete `purrr`. `purrr` es un paquete con herramientas que pueden ayudarte a aplicar funciones en una forma iterativa. 

`purrr` se instala cuando ejecutas run `install.packages("tidyverse")`.  

`purrr` se carga cuando ejecutas `library(tidyverse)`

* Escribe el código para cargar `purrr` (ya está instalado) y luego haz click en _Submit Answer_.

```{r purrr, exercise = TRUE}

```

```{r purrr-check}
'Purrr-fecto. Ahora puedes usar las funciones purrr. También puedes instalar y cargar el paquete purrr sólo, sin los otros paquetes tidyverse. Para hacerlo, usa install.packages("purrr") y library(purrr).'
```

```{r purrr-solution}
library(tidyverse)
```


### map()

El trabajo de la función `map()` de `purrr` es aplicar una función R a cada elemento de un vector R. `map()` requiere dos argumentos, en este orden:

1. Un vector sobre el que iterar. `map()` funciona tanto con vectores simples como con listas.
2. Una función para aplicar a cada elemento del vector. La función `map()` espera el nombre de la función sin las comillas alrededor y sin paréntesis detrás.

En este ejemplo, `map()` aplica la función de valor absoluto a cada elemento de números `negativos`.

```{r echo = TRUE}
negativos <- list(-25, -31, -111)
map(negativos, abs)
```

###  

Piensa en `map()` de esta manera: cada recuadro de cuadraditos representa un vector y cada cuadradito representa un elemento del vector:

```{r echo=FALSE, out.width = "70%"}
knitr::include_graphics("images/map.png")
```

###  

```{r echo = TRUE}
list1 <- list(1, 2, 3, 4, 5)
```

* Utiliza el fragmento de código a continuación para _mapear_ `log()` sobre los elementos de `list1`. Luego hacé clic en _Submit Answer_.

```{r map1, exercise = TRUE, exercise.eval = TRUE}

```

```{r map1-setup}
list1 <- list(1, 2, 3, 4, 5)
```

```{r map1-solution}
map(list1, log)
```

```{r map1-hint-1}
"Empieza con map()."
```

```{r map1-hint-2}
"Poné a list1 como el primer argumento de map()."
```

```{r map1-hint-3}
"Poné log como el segundo argumento de map()."
```

```{r map1-hint-4}
"No ponga paréntesis detrás de log. log devuelve el código almacenado en la función de logaritmo. log() ejecuta el código y devuelve los resultados, que luego se pasarían a map() (en caso que log() no arrojó un error, es decir, en el caso que log() necesita un argumento para ejecutar el código correctamente)."
```

```{r map1-check}
"Excelente. Puedes usar map() con cualquier función para iterar sobre los elementos de un vector. map() devolverá los resultados en una lista, lo que significa que map() puede manejar cualquier salida que cree su función. ¿Por qué? Porque puedes poner cualquier cosa en una lista."
```

### Programación funcional

Puede parecerte extraño que `map()` tome una función como argumento, pero no es extraño en absoluto. En R, las funciones son objetos que se pueden pasar como todos los demás.

Estas preguntas te ayudarán a familiarizarte con esta idea.

* Usa este bloque de código como un bloc de notas para ayudarte a responder las preguntas que aparecen a continuación.

```{r map3, exercise = TRUE}

```

```{r q1, echo=FALSE}
quiz(caption = "",
     question("qué devuelve `log`?",
              answer("0"),
              answer("Un error"),
              answer("La función guardada en el objeto llamado `log`", correct = TRUE, message = "log es solo un objeto que contiene una función. Esto es cierto para los nombres de todas las funciones R. Puedes devolver la función sin ejecutarla llamando al nombre de la función sin paréntesis detrás."),
              allow_retry = TRUE
     ),
     question("Qué retorna `log()`?",
              answer("0"),
              answer("Un error", correct = TRUE, message = 'Los paréntesis son el "botón play" para las funciones R. Cuando colocas los paréntesis detrás del nombre de un objeto que contiene una función, R ejecuta la función. Desafortunadamente, la función log requiere un argumento para hacer su trabajo. No proporcionamos uno aquí, por lo que obtenemos un error. Para ver el efecto de los paréntesis con mayor claridad, compare Sys.Date() con Sys.Date. La función Sys.Date no requiere un argumento.'),
              answer("La función guardada en el objeto llamado `log`"),
              allow_retry = TRUE
     ),
     question("qué devuelve `log(1)`?",
              answer("0", correct = TRUE, message = "Este es el resultado de ejecutar log en 1. Los paréntesis ejecutan la función guardada en log y pasan a la función el argumento 1, que proporcionamos entre paréntesis."),
              answer("Un error"),
              answer("La función guardada en el objeto llamado `log`"),
              allow_retry = TRUE
     )
)
```

Por cierto, deberás hacer clic en _Run Code_ arriba al menos una vez antes de poder continuar.

### ¿Qué pasa con la salida?

Le das a `map()` un vector y una función. `map()` siempre te retorna una lista. El elemento _enécimo_ de la lista será el resultado de aplicar su función al elemento _enécimo_ de su vector.

Esto es conveniente por dos razones:

1. `map()` puede manejar cualquier cosa que salga de tu función, incluso un dataframe. ¿Por qué? Porque puedes poner cualquier cosa en una lista.
2. `map()` es fácil de usar con _pipes_ porque toma un vector como primer argumento y devuelve un vector (una lista es un tipo de vector). Veamos un ejemplo.

* Predice lo que devolverá este código y luego hacé clic en _Submit Answer_.

```{r map2, exercise = TRUE}
list1 %>% 
  map(log) %>% 
  map(round)
```

```{r map2-setup}
list1 <- list(1, 2, 3, 4, 5)
```

```{r map2-hint}
"Hacé clic en Submit Answer para ver si tu predicción es correcta."
```

```{r map2-check}
"El código primero tomó el registro de cada elemento con log(). Luego redondeó cada respuesta al número entero más cercano con round()."
```

## Entradas y Salidas

### Argumentos

¿Qué pasa si desea pasar `map()` una función que usa argumentos adicionales?

Por ejemplo, le darías a `round()` un argumento adicional llamado `digits` si quisieras redondear a un cierto número de dígitos después del lugar decimal, p. ej.

```{r}
round(3.141593, digits = 2)
```

###  

Puedes pasar argumentos adicionales para tu función _a_ `map()` como si fueran argumentos _de_ `map()`. `map()` enviará los argumentos a su función cuando llame a la función. Casi siempre querrá nombrar estos argumentos, p. Ej.

```{r map-args}
list1 %>% 
  map(log) %>% 
  map(round, digits = 2)
```

###  

¿Puedes hacerlo?

* Utiliza el poco conocido argumento `base` de `log()` para calcular el logaritmo base 2 de cada elemento en `list1`. Luego hacé clic en _Submit Answer_.

```{r map4, exercise = TRUE}

```

```{r map4-setup}
list1 <- list(1, 2, 3, 4, 5)
```

```{r map4-solution}
map(list1, log, base = 2)
```

```{r map4-hint}
"Empieza con map(list1, log)."
```

```{r map4-check}
"Buen trabajo. Puede pasar tantos argumentos como desee a través de map(), asegúrese de separar cada uno con una coma, ej. map(list1, rnorm, media = 1, sd = 2)."
```

### Formatos de salida

Hasta ahora, todas nuestras funciones han devuelto una lista de números. Esto es no resulta muy útil, porque (como has visto) puede ser difícil trabajar con listas.

¿Qué sucede si deseas devolver los resultados como un vector simple (es decir, no como una lista)?

### map_dbl()

Puedes hacer eso con `map_dbl()`. 

`map_dbl()` trabaja igual que `map()`, excepto que devuelve sus resultados en un vector numérico. (dbl es la abreviatura de "double", el nombre que se le da en computación a un número que puede contener un decimal).

* Cambia el siguiente código para que use `map_dbl()` luego hacé click en _Submit Answer_.

```{r map_dbl, exercise = TRUE}
map(list1, log)
```

```{r map_dbl-setup}
list1 <- list(1, 2, 3, 4, 5)
```

```{r map_dbl-solution}
map_dbl(list1, log)
```

```{r map_dbl-check}
"Buen trabajo. Ahora sus resultados regresan como un vector numérico. Esto es útil. Por ejemplo, puede pasar los resultados directamente a round() sin usar otra llamada a map(): list1 %>% map_dbl(log) %>% round()."
```

### Otro tipo de salidas

Pero supongamos que nuestra función no devuelve dobles. Por ejemplo, `str_sub()` del paquete `stringr` devuelve caracteres. Aquí, devolverá el primer carácter de cada cadena.

* ¿Funcionará el siguiente código? Hacé clic en _Run code_ para averiguarlo.

```{r map_dbl2, exercise = TRUE}
library(stringr)
strings <- list("Mary", "John", "Jill")
map_dbl(strings, str_sub, start = 1, end = 1)
```

###  

El código no funcionó porque `str_sub()` devuelve un conjunto de caracteres, pero `map_dbl()` construye un vector doble (numérico).

En R, cada vector que no es una lista tiene un _tipo_. Solo puedes guardar _dobles_ en un vector doble. Deberías guardar los caracteres en un _vector de caracteres_. ¿Nos quedamos sin suerte?

###  

No! `purrr` tiene ocho versiones de `map()`. Cada una retorna su resultado en diferente formato. 

Función      | Salida
------------ | -------------
`map()`      |  lista
`map_chr()`  |  vector de characteres (character)
`map_dbl()`  |  vector de dobles (double (numeric))
`map_dfc()`  |  data frame (salida enlazada por columnas)
`map_dfr()`  |  data frame (salida enlazada por filas)
`map_int()`  |  vector de enteros (integer)
`map_lgl()`  |  vector de valores lógicos (logical)
`walk()`     |  devuelve la entrada de forma invisible (se utiliza para desencadenar otras tareas)

La última función, `walk()`, se usa para funciones que no devuelven una salida a la línea de comando, como funciones que trazan gráficos o guardan archivos.
###  

La idea detrás de `purrr` es que puedes elegir la función de `map` que devuelve el tipo de salida que necesitas.

* Reemplaza `map_dbl()` en el código siguiente con la función que permitirá que el código funcione. Luego hacé clic en _Submit Answer_.

```{r map_chr, exercise = TRUE}
strings <- list("María", "Juan", "René")

map_dbl(strings, str_sub, start = 1, end = 1)
```

```{r map_chr-hint}
"str_sub() retorna caracteres."
```

```{r map_chr-solution}
strings <- list("María", "Juan", "René")

map_chr(strings, str_sub, start = 1, end = 1)
```

```{r map_chr-check}
"Gran trabajo. Ahora reforcemos nuestro conocimiento de `map()` usándolo para resolver un desafío de datos."
```

## Caso de Estudio

###  

`ldeaths` es una lista que registra las muertes mensuales en el Reino Unido por enfermedades pulmonares. Los datos abarcan los años 1974 a 1979 y están divididos por año.

* Echale un vistazo. Hacé clic en _Submit Answer_ para ver el contenido de `ldeaths`.

```{r ldeaths-1, exercise = TRUE}
ldeaths
```

```{r ldeaths-1-check}
"This is the data you will explore. ldeaths is a reformatted version of the ldeaths time series that comes in base R."
```

### Deaths by year

It would be helpful to know how many people died each year from lung disease. Then you could see if deaths decreased over time. Can you find out?

* Use a map function to compute the sum of each vector in `ldeaths`. Then click Submit Answer.

```{r ldeaths-sum, exercise = TRUE}

```

```{r ldeaths-sum-hint}
"The sums will be numbers (doubles)."
```

```{r ldeaths-sum-solution}
map_dbl(ldeaths, sum)
```

```{r ldeaths-sum-check}
"Good job. It looks like deaths went down over time (slightly). Did you use map() or map_dbl()? Both will work, but map_dbl() will return your results in a format that is easier to inspect and use."
```

### Total deaths

Take it a step further.

* Compute the _total_ number of deaths in the data set. This will be the sum of your last result. Then click Submit Answer.

```{r ldeaths-total, exercise = TRUE}

```

```{r ldeaths-total-hint-1}
"This will take two steps."
```

```{r ldeaths-total-hint-2}
"The second step will be easier if you use map_dbl() in your first step."
```

```{r ldeaths-total-solution}
sum(map_dbl(ldeaths, sum))
```

```{r ldeaths-total-check}
"Good work. First, you summed each vector. Then, you summed the results. It is easiest to sum the results if you use map_dbl() to sum the vectors."
```

### Pipes

Now that you are doing multi-step operations, you should begin using the pipe operator if you aren't already. The pipe operator (`%>%`) is great for single step operations too.

* Take a moment to convert this code to use the pipe operator. Then click Submit Answer.

    Note: Recall that the pipe operator takes the output of whatever is on its left hand side and passes it to the first argument of the function that is on its right hand side. So `x %>% f()` is the same as `f(x)` and `x %>% f() %>% g()` is the same as `g(f(x))`.

```{r ldeaths-pipe, exercise = TRUE}
sum(map_dbl(ldeaths, sum))
```

```{r ldeaths-pipe-hint}
"You will need to use two pipe operators to convert this expression into a pipe."
```

```{r ldeaths-pipe-solution}
ldeaths %>% 
  map_dbl(sum) %>%
  sum()
```

```{r ldeaths-pipe-check}
"Use pipes for the rest of this case study. Pipes make it easy to build on previous work and to transform your data one step at a time. I can't recommend pipes enough."
```

### Sum by month

Let's sum across months to see if there is a seasonal effect. 

Mathematically, this is as simple as your previous computations. Programatically, it is a challenge: your data is not set up in a way that makes it easy to sum across months. You'll need a strategy.

###  

If you've taken the Work with Data primer recently, you might have a strategy in mind:

1. If you can get your data to look like this:

```{r echo = FALSE}
ldeaths %>% 
  map(t) %>% 
  map_dfr(as_tibble)
```

2. Then you can use dplyr's `summarise()` function to sum the columns.

Do just that, but fair warning: you're going to bump into a couple of surprises---just like when you wrangle data in real life.

### Step 1 - A data frame

For Step 1, you can use a map function to combine your vectors into a data frame. Do you recall which map functions return a single data frame? There were two of them.

###  

1. `map_dfr()` adds each element to the first as _rows_ (exactly what you want)
2. `map_dfc()` adds each element to the first as _columns_

But each function expects to iterate over a set of _data frames_ and `ldeaths` contains a set of vectors. To make `map_dfr()` work, you will need to pass it a function that turns the vectors in `ldeaths` into data frames for `map_dfr()` to combine.

### as_tibble()

R has many functions that can turn a vector into a data frame: `data.frame()`, `as.data.frame()`, `data_frame()`, `as_data_frame()`, are some of them. 

I prefer to use `as_tibble()`. `as_tibble()` converts the vector to a data frame _and_ adds the helpful tibble class to the data frame. As a result, the data frame prints nicely at the command line. 

* Try it out. Use `as_tibble()` to convert the vector below into a data frame.

```{r as_tibble, exercise = TRUE}
named_vec <- c(uno = 1, dos = 2, tres = 3)
named_vec
```

```{r as_tibble-solution}
named_vec <- c(uno = 1, dos = 2, tres = 3)
as_tibble(named_vec)
```

```{r as_tibble-check}
"Good job. as_tibble() comes in the tibble package, as do as_data_frame() and data_frame(). Like purrr, the tibble package is a member of the tidyverse."
```

###  

Now that you know how `as_tibble()` works,

* Use `map()` to map `as_tibble()` over the vectors in `ldeaths`. Then click Submit Answer. (For now, use `map()` instead of `map_dfr()`, this will help you see what happens step-by-step as you wrangle the data.)
* Inspect the results closely. What happens?

```{r as_tibble-2, exercise = TRUE}

```

```{r as_tibble-2-solution}
ldeaths %>% 
  map(as_tibble)
```

```{r as_tibble-2-check}
"Good job, you made each vector a tibble (i.e. a data frame)! But there is something funny happening here. Let's investigate."
```

### Row or column?

`as_tibble()` turned each vector into a data frame with one _column_. If you want the data frame below, you'll need to turn each vector into a data frame with one _row_ (that way `map_dfr()` can stack the rows on top of one another).

```{r echo = FALSE}
ldeaths %>% 
  map(t) %>% 
  map_dfr(as_tibble)
```

If you try running `map_dfr()` on our current output, it will stack your columns on top of one another to make a data frame with one long column. Go ahead, try it.

* Click Submit Answer. 

```{r fail, exercise = TRUE}
ldeaths %>% 
  map_dfr(as_tibble)
```

```{r fail-solution}
ldeaths %>% 
  map_dfr(as_tibble)
```

```{r fail-check}
"That's not what you want."
```

### How can you fix this?

Even though R displays simple vectors as if they were _row vectors_, R thinks of every vector as a _column vector_, even if that vector has names. So why display the vector as a row vector? To save screen space.

```{r}
ldeaths[[1]]
```

You can get the data frames you want if you first transpose the column vectors in `ldeaths` to row vectors. 

### t()

R's `t()` function does just that. 

```{r}
ldeaths[[1]]

t(ldeaths[[1]])
```

Don't be fooled by the way R displays the vectors. R only thinks of the second vector as a row vector. You can tell by the bracket notation in front of the vector. It indicates that this is the first _row_ of the result (but you can ignore the notation if it doesn't interest you).

### A data set

Now you can finish Step 1.

1. Use `map()` to apply `t()` to each vector in `ldeaths`.
2. Use `map_dfr()` to map `as_tibble()` over the transposed results. `map_dfr()` will combine the output into a single data frame. 
3. Click Submit Answer

```{r t, exercise = TRUE}

```

```{r t-solution}
ldeaths %>% 
  map(t) %>% 
  map_dfr(as_tibble)
```

```{r t-check}
"Excellent. Now you can finish."
```

### Step 2 - summarise()

How would you extend this code with `summarise()` from the dplyr package to compute the monthly totals?

_(You may need to take the Work with Data Primer to understand these final three sections.)_

```{r}
ldeaths %>% 
  map(t) %>% 
  map_dfr(as_tibble)
```

###  

Here's a surefire way to do it, but it requires a lot of typing; I'm summarising every column in the data frame. Let's use a shortcut instead.

```{r eval = FALSE}
ldeaths %>% 
  map(t) %>% 
  map_dfr(as_tibble) %>% 
  summarise(Jan = sum(Jan), 
            Feb = sum(Feb),
            Mar = sum(Mar),
            Apr = sum(Apr),
            May = sum(May),
            Jun = sum(Jun), 
            Jul = sum(Jul),
            Aug = sum(Aug),
            Sep = sum(Sep),
            Oct = sum(Oct),
            Nov = sum(Nov),
            Dec = sum(Dec))
```

### summarise_all()

dplyr contains a variant of `summarise()` named `summarise_all()`. To use `summarise_all()` give it a data frame and then one or more functions to apply to each column in the data frame. `summarise_all()` will apply each function to every column and return the results as a summary table.

* Use `summarise_all()` and the code below to sum across months. Look at the hints if you get stuck. Then click Submit Answer.

```{r all, exercise = TRUE}
ldeaths %>% 
  map(t) %>% 
  map_dfr(as_tibble)
```

```{r all-hint}
"You do not need to pass summarise_all() a data frame; it will inherit one from the pipe."
```

```{r all-solution}
ldeaths %>% 
  map(t) %>% 
  map_dfr(as_tibble) %>% 
  summarise_all(sum)
```

```{r all-check}
"Great Job! You can see a strong seasonal effect in the data: more lung related deaths happen in winter. You were able to do this because of the work you put into wrangling the data with purrr. Give yourself a pat on the back!"
```

### The End

Congratulations on making it to the end. You've learned the ins and outs of iterating with `map()`, but there is more to know.

When you are ready, the next tutorial will show you how to save a lot of time with `map()`'s syntax shortcuts. It will also show you what to do when you cannot find a function to map that does what you want.
